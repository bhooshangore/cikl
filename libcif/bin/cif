#!/usr/bin/env perl

use strict;
use warnings;

# fix lib paths, some may be relative
BEGIN {
    require File::Spec;
    my @libs = (
        "lib", 
        "local/lib",
        "../libcif/lib", # in case we're in -dev mode
    );
    my $bin_path;

    for my $lib (@libs) {
        unless ( File::Spec->file_name_is_absolute($lib) ) {
            unless ($bin_path) {
                if ( File::Spec->file_name_is_absolute(__FILE__) ) {
                    $bin_path = ( File::Spec->splitpath(__FILE__) )[1];
                }
                else {
                    require FindBin;
                    no warnings "once";
                    $bin_path = $FindBin::Bin;
                }
            }
            $lib = File::Spec->catfile( $bin_path, File::Spec->updir, $lib );
        }
        unshift @INC, $lib;
    }
}

use CIF::Client;
use Getopt::Std;
use JSON::XS;
use CIF qw/debug/;

use CIF::Report::QueryResultsReport;
use CIF::Report::CSVFormatter;
use CIF::Report::TableFormatter;


my %opts;
getopt('D:S:O:G:l:g:THL:p:f:q:c:s:r:C:zP:Fe:', \%opts);

our $debug       = ($opts{'d'}) ? 1 : 0;

# config opts
my $config      = $opts{'C'} || $ENV{'HOME'}.'/.cif';
my $outfile     = $opts{'O'};
my $query       = $opts{'q'} || shift;

# query options
my $nolog       = $opts{'n'} || 0;
my $confidence  = $opts{'c'};
my $guid        = $opts{'g'};
my $limit       = $opts{'l'};

# plugin opts
my $plugin      = $opts{'p'} || 'Table';
my $fields      = $opts{'f'};
my $max_desc    = $opts{'L'} || 100;


# display options
my $summary             = $opts{'S'};
my $nomap               = $opts{'N'};
our $uuid               = $opts{'u'} || 0;
our $relateduuid        = $opts{'R'} || 0;
my $round_confidence    = $opts{'I'} || 0;
my $group_map           = (defined($opts{'G'})) ? $opts{'G'} : 1;
my $compress_address    = (defined($opts{'z'})) ? $opts{'z'} : 1;
my $table_showmeta      = $opts{'M'} || 0;
my $filter_me           = $opts{'F'};
my $sortby              = $opts{'S'} || 'detecttime';
my $sortby_direction    = $opts{'D'} || 'DESC';
my $exclude_assessment   = $opts{'e'};
my $new_only            = $opts{'m'} || 0;

die usage() unless($query);
die usage() if($opts{'h'});

sub usage {
    return <<EOF;
Usage: perl $0 -q xyz.com

Standard Options:
    -h  --help:             this message
    -C  --config:           specify cofiguration file, default: $config
    
Query Options:
    -q  --query:            query string
    -n  --nolog:            perform a "silent" query (no log query), default: $nolog
    -l  --limit:            set the default result limit (queries only), default is set on server, usually around 500.
    -c  --confidence:       lowest tolerated confidence (0.00 -- 100.00), default $confidence
    
Format Options:
    -p  --plugin:           output plugin ('Table','Csv'), default: Table
    -f  --fields:           set default output fields for default table display
    -S  --summary:          consolidated Text::Table output (default: True)
    -N  --nomap:            don't map restrictions
    -g  --guid:             filter by a specific group id (guid), ex: group1.example.com
    -G  --groupmap:         turn group mapping (guid to 'group name') on/off, default: $group_map
    -e  --exclude:          exclude a specific assessment (search,botnet,malware, etc).
    
Nonstandard Options:
    -z                      compact address field to 32 chars, applies only to defalt table output, default: 1 (0 turns it off)
    -I  --round-confidence: round (down) confidence to the nearest integer, default 0.
    -m                      return only the results where "\$DETECTTIME >= \$TODAY (UTC)" (the most recent results from a feed)
    -F  --filter-me:        exclude results based on my apikey (usually logged searches)

Example Queries:

    \$> perl $0 -q 1.2.3.4
    \$> perl $0 -q 1.2.3.0/24
    \$> perl $0 -q f8e74165fb840026fd0fce1fd7d62f5d0e57e7ac
    \$> perl $0 -q hut2.ru
    \$> perl $0 -q hut2.ru,f8e74165fb840026fd0fce1fd7d62f5d0e57e7ac
    \$> perl $0 hut2.ru
    
    \$> perl $0 -q malware
    \$> perl $0 -q malware
    \$> perl $0 -q infrastructure/botnet -p csv 
    \$> perl $0 -q domain/malware -p bindzone -c 95
    \$> perl $0 -q domain -c 40
    
    \$ $0 -d -q example.com -e search

Configuration:

    configuration file ~/.cif should be readable and look something like:

    [client]
    apikey = xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
    driver = 'http'
    
    # table_nowarning = 1
    # csv_noseperator = 1
    
    [client_http]
    host = https://example.com:443/api
    timeout = 60
    
    # add this if you have a self signed cert
    verify_tls = 0
    
    # proxy settings
    # proxy = https://localhost:5555

EOF
}


$plugin = lc($plugin);
my $formatter;
if ($plugin eq 'csv') {
  $formatter = CIF::Report::CSVFormatter->new();
} elsif ($plugin eq 'table') {
  $formatter = CIF::Report::TableFormatter->new();
}

if (!defined($formatter)) {
    print usage();
    print "ERROR: Unknown formatter ($plugin) specified.\n";
    exit(0);
}

if($exclude_assessment && $exclude_assessment =~ /\,/){
    print usage();
    print '-e only accepts a single assessment at this time'."\n";
    exit(0);
}

my ($err,$cli) = CIF::Client->new({
    config          => $config,
});

if($err){
    print 'ERROR: '.$err."\n";
    exit(-1);
}

# else we're doing query
if($outfile){
    open(F,">",$outfile) || die($!);
}

my $orig_query = $query;

# make sure if there are no spaces between queries
$query =~ s/\s//g;

#my @q = split(/,/,$query);
my $query_results;
($err,$query_results) = $cli->search($orig_query, {
    filter_me           => $filter_me,
    nolog               => $nolog,
    no_maprestrictions  => $nomap,
    confidence          => $confidence,
    limit               => $limit,
});
$cli->shutdown();


if($err){
    print 'ERROR: '.$err."\n";
    exit(-1);
}
unless($query_results){
    debug('no results...') if($debug);
    exit(0);
}

debug('formatting as '.ucfirst($plugin).'...');

$fields = [ split(/,/,$fields) ] if($fields);

my @text;


my $output = *STDOUT;

if($outfile){
  $output = *F;
}

my $report = CIF::Report::QueryResultsReport->new($query_results);
$formatter->generate_report($report, $output);

if ($outfile) {
  close(F);
}
