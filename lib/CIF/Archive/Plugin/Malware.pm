package CIF::Archive::Plugin::Malware;
use base 'CIF::Archive::Plugin';

use strict;
use warnings;

use Module::Pluggable require => 1, search_path => [__PACKAGE__];

__PACKAGE__->table('malware');
__PACKAGE__->columns(Primary => 'id');
__PACKAGE__->columns(All => qw/id uuid guid hash confidence reporttime created/);
__PACKAGE__->sequence('malware_id_seq');

my @plugins = __PACKAGE__->plugins();

use constant DATATYPE => 'malware';
sub datatype { return DATATYPE; }

sub query { } # handled by the address module

sub match_event {
    my $class = shift;
    my $event = shift;
    my $ret = $class->SUPER::match_event($event);
    if ($ret == 0) {
      return 0;
    }
    if (defined($event->address)) {
      return 0;
    }
    my $hash = $event->{$class->hash_field()};
    unless (defined($hash)) {
      return 0;
    }
    if (lc($hash) !~ $class->hash_regex()) {
      return 0;
    }
    return 1;
}

sub insert {
    my $class = shift;
    my $data = shift;
    my $event = $data->{event};
    
    my @ids;

    my $hash = $event->{$class->hash_field()};
    if($class->test_feed($data)){
      $class->SUPER::insert({
          hash        => $hash,
          uuid        => $event->uuid,
          guid        => $event->guid,
          confidence  => $event->confidence,
          reporttime  => $event->reporttime,
        });
    }
    my $id = $class->insert_hash({ 
        uuid        => $event->uuid, 
        guid        => $event->guid, 
        confidence  => $event->confidence,
        reporttime  => $event->reporttime,
      },$hash);
    ## TODO: mem leak?
    push(@ids,@$id);
    return(undef,\@ids);
}

sub hash_regex {
  my $class = shift;
  die("$class->hash_regex needs to be defined.");
}

sub hash_field {
  my $class = shift;
  die("$class->hash_field needs to be defined.");
}

1;
